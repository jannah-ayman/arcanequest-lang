ARCANEQUEST LANGUAGE GRAMMAR SPECIFICATION
==========================================

PROGRAM STRUCTURE
-----------------
Program         → Statement* EOF
Statement       → Comment | KeywordStmt | Assignment | CompoundAssignment 
                  | ExprStmt | NEWLINE
KeywordStmt     → ImportStmt | IfStmt | WhileStmt | ForStmt 
                  | FunctionDef | ClassDef | OutputStmt | InputStmt
                  | TryExcept | Return | Continue | Break

LEXICAL ELEMENTS
----------------
Comment         → '-->' TEXT

KEYWORDS
--------
summon          → import statement
quest           → function definition
reward          → return statement
attack          → output/print statement
scout           → input statement
spot            → if statement
counter         → elif clause
dodge           → else clause
replay          → while loop
farm            → for loop
guild           → class definition
embark          → try block
gameOver        → except handler
savePoint       → finally block
skipEncounter   → continue statement
escapeDungeon   → break statement

DATA TYPES
----------
potion          → integer type
elixir          → float type
fate            → boolean type
scroll          → string type

LITERALS
--------
Number          → INTEGER | FLOAT
                  INTEGER  → [0-9]+
                  FLOAT    → [0-9]+ '.' [0-9]+
String          → STRING_LITERAL
                  STRING_LITERAL → '"' CHAR* '"' | "'" CHAR* "'"
Literal         → 'true' | 'false'
Identifier      → [A-Za-z_][A-Za-z0-9_]*

OPERATORS
---------
Arithmetic      → '+' | '-' | '*' | '/' | '//' | '%' | '**'
Comparison      → '==' | '!=' | '<' | '>' | '<=' | '>='
Logical         → 'and' | 'or' | 'not'
Assignment      → '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '**='

PUNCTUATION
-----------
Delimiters      → '(' | ')' | '{' | '}' | '[' | ']'
Separators      → ':' | ',' | '.'

IMPORT STATEMENTS
-----------------
ImportStmt      → 'summon' Identifier (',' Identifier)*

Example:
  summon random, sys, math

VARIABLE ASSIGNMENT
-------------------
Assignment      → Identifier '=' (InputStmt | Expr)
CompoundAssignment → Identifier CompoundOp Expr
CompoundOp      → '+=' | '-=' | '*=' | '/=' | '%=' | '**='

Examples:
  x = 10
  name = scout("Enter name: ")
  count += 1
  value *= 2

INPUT/OUTPUT STATEMENTS
-----------------------
InputStmt       → 'scout' '(' Expr ')'
OutputStmt      → 'attack' '(' (Expr (',' Expr)*)? ')'

Examples:
  name = scout("What's your name? ")
  attack("Hello, World!")
  attack("Score:", score, "Health:", health)

CONTROL FLOW - CONDITIONALS
----------------------------
IfStmt          → 'spot' '(' Expr ')' ':' Block
                  ('counter' '(' Expr ')' ':' Block)*
                  ('dodge' ':' Block)?

Example:
  spot (health > 50):
      attack("Healthy!")
  counter (health > 20):
      attack("Wounded!")
  dodge:
      attack("Critical!")

CONTROL FLOW - LOOPS
---------------------
WhileStmt       → 'replay' '(' Expr ')' ':' Block
ForStmt         → 'farm' Identifier 'in' Expr ':' Block
Continue        → 'skipEncounter'
Break           → 'escapeDungeon'

Examples:
  replay (count < 10):
      attack(count)
      count += 1
  
  farm item in inventory:
      attack("Found:", item)

FUNCTION DEFINITIONS
--------------------
FunctionDef     → 'quest' Identifier '(' ParamList? ')' ':' Block
ParamList       → Identifier (',' Identifier)*
Return          → 'reward' Expr

Example:
  quest greet(name, title):
      attack("Hello", title, name)
      reward "Welcome!"

EXCEPTION HANDLING
------------------
TryExcept       → 'embark' ':' Block
                  ('gameOver' Identifier? ':' Block)*
                  ('savePoint' ':' Block)?

Example:
  embark:
      risky_operation()
  gameOver ValueError:
      attack("Invalid value!")
  gameOver:
      attack("Unknown error!")
  savePoint:
      attack("Cleanup complete")

BLOCKS
------
Block           → NEWLINE INDENT Statement+ DEDENT

Note: Indentation must be consistent throughout the program.
First indent establishes the standard (e.g., 4 spaces).

EXPRESSIONS
-----------
Expr            → LogicalOrExpr

OPERATOR PRECEDENCE (Low to High)
----------------------------------
1. or           → logical OR (lowest precedence)
2. and          → logical AND
3. not          → logical NOT (unary)
4. == != < > <= >=  → comparison operators
5. + -          → addition, subtraction
6. * / // %     → multiplication, division, floor division, modulo
7. **           → exponentiation (highest precedence, right-associative)

Unary operators: not, +, -

EXPRESSION GRAMMAR
------------------
LogicalOrExpr   → LogicalAndExpr ('or' LogicalAndExpr)*
LogicalAndExpr  → ComparisonExpr ('and' ComparisonExpr)*
ComparisonExpr  → AddExpr (CompOp AddExpr)*
                  CompOp → '==' | '!=' | '<' | '>' | '<=' | '>='
AddExpr         → Term (('+' | '-') Term)*
Term            → ExponentExpr (('*' | '/' | '//' | '%') ExponentExpr)*
ExponentExpr    → UnaryExpr ('**' UnaryExpr)*  [right-associative]
UnaryExpr       → ('not' | '+' | '-') UnaryExpr | PostfixExpr
PostfixExpr     → PrimaryExpr (CallSuffix | AttributeSuffix)*

PrimaryExpr     → Number | String | Literal | Identifier | Datatype
                  | '(' Expr ')'

FUNCTION CALLS
--------------
CallSuffix      → '(' ArgList? ')'
ArgList         → Expr (',' Expr)*

Examples:
  attack("Hello")
  math.sqrt(16)
  potion("42")     → type casting
  player.take_damage(10)

ATTRIBUTE ACCESS
----------------
AttributeSuffix → '.' Identifier

Examples:
  player.health
  sys.exit
  object.method.chain

TYPE CASTING
------------
Datatypes can be used as casting functions:
  potion(x)       → cast x to integer
  elixir(x)       → cast x to float
  fate(x)         → cast x to boolean
  scroll(x)       → cast x to string

SEMANTIC RULES
--------------
1. Variables must be declared before use (through assignment)
2. Type checking for operations:
   - Arithmetic operators (+, -, *, /, //, %, **) require numeric types (potion/elixir)
   - Result of division (/) is always elixir (float)
   - Mixed potion and elixir operations return elixir
   - Logical operators (and, or) require boolean type (fate)
   - not operator requires boolean operand
   - Comparison operators (<, >, <=, >=) require numeric operands, return fate
   - Equality operators (==, !=) require same types, return fate
   - String concatenation: scroll + scroll → scroll
   - String repetition: scroll * potion or potion * scroll → scroll
3. Condition expressions (in spot, counter, replay) must evaluate to boolean (fate)
4. Function return types are inferred from reward statements
5. Function parameters have types inferred from context
6. Scoping rules:
   - Global scope
   - Function scope (new scope for each function)
   - Block scope (new scope for if/while/for/try blocks)
7. Indentation must be consistent (first indent sets standard)
8. Compound assignments (+=, -=, etc.) require variable to be declared
9. Input (scout) always returns scroll type

TYPE INFERENCE SYSTEM
--------------------
- Literals: 
  * Integer numbers → potion
  * Float numbers → elixir
  * Strings → scroll
  * true/false → fate
  
- Variables: inferred from assigned expression

- Binary operations:
  * Arithmetic (+, -, *, /, //, %, **):
    - potion op potion → potion (except / → elixir)
    - elixir op numeric → elixir
    - numeric op elixir → elixir
    - scroll + scroll → scroll
    - scroll * potion → scroll
    - potion * scroll → scroll
  * Comparison (<, >, <=, >=):
    - numeric op numeric → fate
  * Equality (==, !=):
    - same_type op same_type → fate
  * Logical (and, or):
    - fate op fate → fate

- Unary operations:
  * not fate → fate
  * +/- numeric → numeric (preserves type)

- Function calls:
  * Type casting functions (potion, elixir, fate, scroll) → respective type
  * User functions → inferred from reward statements in function body
  * Unknown functions → unknown type

- Input statements:
  * scout(...) → scroll

- Symbol table:
  * Tracks variables and their types across scopes
  * Supports nested scopes with proper lookup
  * Updates types on reassignment

ERROR RECOVERY
--------------
Parser uses panic-mode error recovery:
- Synchronizes at statement boundaries (NEWLINE, keywords)
- Continues parsing after errors
- Reports multiple errors in single pass
- Provides partial parse tree even with errors
- Separates parse errors from semantic errors

ERROR TYPES
-----------
Parse Errors:
- Syntax errors (missing punctuation, unexpected tokens)
- Invalid statement structure
- Indentation errors

Semantic Errors:
- Type mismatches in operations
- Undeclared variables
- Non-boolean conditions
- Invalid type conversions
- Cannot determine type for expressions

IMPLEMENTATION NOTES
-------------------
- Scanner performs lexical analysis with indentation tracking
- Parser builds Abstract Syntax Tree (AST) with type annotations
- Symbol table maintains variable/function declarations
- Type inference performed during parsing
- Function return types inferred by analyzing function bodies
- Supports forward type inference for function calls with known argument types